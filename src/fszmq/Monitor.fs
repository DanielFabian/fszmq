
(* ------------------------------------------------------------------------
This file is part of fszmq.

fszmq is free software: you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published 
by the Free Software Foundation, either version 3 of the License, or
(at your option) any later version.

fszmq is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with fszmq. If not, see <http://www.gnu.org/licenses/>.

Copyright (c) 2011-2013 Paulmichael Blasucci
------------------------------------------------------------------------ *)
namespace fszmq

open System
open System.Runtime.CompilerServices
open System.Runtime.InteropServices
open System.Text

/// Encapsulates data generated by various ZMQ monitoring events
type ZMQEvent = 
  { EventID : uint16
    Address : string
    Details : ZMQEventDetails }
/// Provides more-granular information about a ZMQEvent
and ZMQEventDetails =
  | Connected       of handle   : int
  | ConnectDelayed
  | ConnectRetried  of interval : int
  | Listening       of handle   : int
  | BindFailed      of error    : ZMQError
  | Accepted        of handle   : int
  | AcceptFailed    of error    : ZMQError
  | Closed          of handle   : int
  | CloseFailed     of error    : ZMQError
  | Disconnected    of handle   : int
  | MonitorStopped
  | Unknown

/// Contains methods for working with Socket diagnostics
[<Extension>]
module Monitor =

    // Constructs a ZMQEventDetails instance based on a (native) ZeroMQ event and associated data
    let private buildEventDetails (event,data) =
      match event with
      // data is a reconnect interval
      | ZMQ.EVENT_CONNECT_RETRIED -> ConnectRetried data
      // data is a socket handle (a.k.a. file descriptor, or fd)
      | ZMQ.EVENT_LISTENING       -> Listening    data
      | ZMQ.EVENT_CONNECTED       -> Connected    data
      | ZMQ.EVENT_ACCEPTED        -> Accepted     data
      | ZMQ.EVENT_CLOSED          -> Closed       data
      | ZMQ.EVENT_DISCONNECTED    -> Disconnected data
      // data is a ZeroMQ error number (for use with ZMQError)
      | ZMQ.EVENT_BIND_FAILED     -> BindFailed   (ZMQ.buildError data)
      | ZMQ.EVENT_ACCEPT_FAILED   -> AcceptFailed (ZMQ.buildError data)
      | ZMQ.EVENT_CLOSE_FAILED    -> CloseFailed  (ZMQ.buildError data)
      // data is meaningless
      | ZMQ.EVENT_CONNECT_DELAYED -> ConnectDelayed
      | ZMQ.EVENT_MONITOR_STOPPED -> MonitorStopped
      | _                         -> Unknown

    /// Constructs a ZMQEvent option from a raw (binary) message
    [<CompiledName("TryBuildEvent")>]
    let tryBuildEvent message =
      match message with
      | [| details; address; |] ->
        match Array.length details with
        | n when n = ZMQ.EVENT_DETAIL_SIZE ->
            let event = BitConverter.ToUInt16(details,0)
            let value = BitConverter.ToInt32 (details,sizeof<uint16>)
            { EventID = event; 
              Address = Encoding.UTF8.GetString(address); 
              Details = buildEventDetails (event,value) }
            |> Some
        | _ -> None
      | _   -> None
   
    /// Constructs a ZMQEvent from a raw (binary) message; 
    /// will raise exception if message format is incorrect
    [<CompiledName("BuildEvent")>]
    let buildEvent message =
      match tryBuildEvent message with
      | Some zmqEvent -> zmqEvent
      | None          -> ZMQ.einval "Not an event"

    /// Tries to receive the next ZMQEvent from a monitor socket
    [<Extension;CompiledName("TryRecvEvent")>]
    let tryRecvEvent socket =
      socket 
      |> Socket.recvAll 
      |> tryBuildEvent
    
    /// Receives the next ZMQEvent from a monitor socket; 
    /// will raise exception if called on a non-monitor socket
    [<Extension;CompiledName("RecvEvent")>]
    let recvEvent socket =
      match tryRecvEvent socket with
      | Some zmqEvent -> zmqEvent
      | None          -> ZMQ.einval "Invalid endpoint"
